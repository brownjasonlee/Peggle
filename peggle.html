<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Peggle — Single‑File</title>
    <style>
      html, body {
        margin: 0;
        height: 100%;
        background: radial-gradient(1200px 800px at 50% 0%, #0b1736 0%, #0a0f24 60%, #060a18 100%);
        color: #e8eefc;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        overflow: hidden;
      }
      #wrap { position: fixed; inset: 0; display: grid; place-items: center; }
      canvas { display: block; background: transparent; image-rendering: optimizeQuality; }
      .hud {
        position: fixed; left: 50%; top: 16px; transform: translateX(-50%);
        display: flex; gap: 24px; align-items: center; padding: 6px 12px;
        background: rgba(10,16,30,0.45); border: 1px solid rgba(255,255,255,0.08);
        border-radius: 999px; backdrop-filter: blur(8px);
        box-shadow: 0 6px 24px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.06);
        pointer-events: auto; user-select: none;
        font-weight: 600; letter-spacing: 0.2px; font-size: 14px;
        font-variant-numeric: tabular-nums; font-feature-settings: 'tnum';
      }
      .hud .pill { padding: 4px 12px; border-radius: 999px; background: rgba(255,255,255,0.06); display: flex; align-items: center; gap: 6px; white-space: nowrap; }
      .hud .lbl { font-weight: 800; opacity: 0.95; }
      .hud .accent { color: #8ec7ff; display: inline-block; text-align: right; }
      .pill.score .accent { width: 8ch; }
      .pill.balls .accent { width: 2ch; }
      .pill.targets .accent { width: 3ch; }
      .pill.streak .accent { width: 3ch; }
      .controls { display: flex; gap: 8px; }
      .btn { cursor: pointer; padding: 6px 12px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.08); color: #e8eefc; font-weight: 700; letter-spacing: 0.2px; }
      .btn:hover { background: rgba(255,255,255,0.14); }
      .btn:active { transform: translateY(1px); }
      .options {
        position: fixed; top: 64px; right: 16px; padding: 14px 16px; border-radius: 12px;
        background: rgba(10,16,30,0.6); border: 1px solid rgba(255,255,255,0.1);
        box-shadow: 0 12px 36px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.06);
        backdrop-filter: blur(8px); color: #e8eefc; font-size: 14px;
      }
      .options h3 { margin: 0 0 8px; font-size: 14px; font-weight: 800; letter-spacing: 0.3px; opacity: 0.9; }
      .opt-row { display: flex; align-items: center; gap: 10px; margin: 8px 0; }
      .opt-label { opacity: 0.85; min-width: 120px; }
      .opt-note { opacity: 0.6; font-size: 12px; }
      .seg { display: inline-flex; gap: 6px; }
      .seg button { cursor: pointer; padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.06); color: #e8eefc; }
      .seg button.active { background: rgba(166,209,255,0.18); border-color: rgba(166,209,255,0.5); }
      .seg.disabled { opacity: 0.4; pointer-events: none; }
      /* overlay removed */
      .footer { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.6; }
      a { color: #a6d1ff; text-decoration: none; border-bottom: 1px dotted rgba(166,209,255,0.5); }
    </style>
  </head>
  <body>
    <div id="wrap"><canvas id="game"></canvas></div>
    <div class="hud" id="hud">
      <div class="pill score"><span class="lbl">Score</span><span id="score" class="accent">0</span></div>
      <div class="pill balls"><span class="lbl">Balls</span><span id="balls" class="accent">5</span></div>
      <div class="pill targets"><span class="lbl">Targets</span><span id="targets" class="accent">0</span></div>
      <div class="pill streak"><span class="lbl">Streak</span><span id="streak" class="accent">0</span></div>
      <div class="controls">
        <button class="btn" id="btnRestart" title="Restart with a new layout">Restart</button>
        <button class="btn" id="btnOptions" title="Toggle options">Options</button>
      </div>
    </div>
    <div class="options" id="optionsPanel" hidden>
      <h3>Options</h3>
      <div class="opt-row">
        <div class="opt-label">Preset</div>
        <select id="selPreset">
          <option value="">Custom</option>
        </select>
      </div>
      <div class="opt-row">
        <div class="opt-label">Guide</div>
        <div class="seg" id="segGuideOn">
          <button data-on="0">Off</button>
          <button data-on="1" class="active">On</button>
        </div>
      </div>
      <div class="opt-row">
        <div class="opt-label">Guide bounces</div>
        <div class="seg" id="segBounces">
          <button data-v="0">0</button>
          <button data-v="1">1</button>
          <button data-v="2">2</button>
          <button data-v="3">3</button>
          <button data-v="4">4</button>
        </div>
      </div>
      <div class="opt-row">
        <div class="opt-label">Guide length</div>
        <input id="slGuideMs" type="range" min="800" max="3000" value="2000" />
        <span id="lblGuideMs">2000</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Guide density</div>
        <input id="slGuideDensity" type="range" min="1" max="10" value="4" />
        <span id="lblGuideDensity">4</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Guide fade</div>
        <label>Start <input id="slGuideFadeStart" type="range" min="0" max="1" step="0.05" value="0.6" /></label>
        <label>End <input id="slGuideFadeEnd" type="range" min="0" max="1" step="0.05" value="0.12" /></label>
      </div>
      <div class="opt-row">
        <div class="opt-label">Gravity</div>
        <input id="slGravity" type="range" min="400" max="1800" value="1200" />
        <span id="lblGravity">1200</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Restitution</div>
        <label>Ball <input id="slRestBall" type="range" min="0.6" max="1.0" step="0.01" value="0.96" /></label>
        <label>Peg <input id="slRestPeg" type="range" min="0.6" max="1.0" step="0.01" value="0.94" /></label>
        <label>Wall <input id="slRestWall" type="range" min="0.6" max="1.0" step="0.01" value="0.90" /></label>
      </div>
      <div class="opt-row">
        <div class="opt-label">Air drag</div>
        <input id="slDrag" type="range" min="0.995" max="1.000" step="0.0005" value="0.999" />
        <span id="lblDrag">0.999</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Time step</div>
        <select id="selHz">
          <option value="60">60 Hz</option>
          <option value="90">90 Hz</option>
          <option value="120" selected>120 Hz</option>
          <option value="144">144 Hz</option>
        </select>
      </div>
      <div class="opt-row">
        <div class="opt-label">Launch speed</div>
        <input id="slLaunch" type="range" min="600" max="1000" value="780" />
        <span id="lblLaunch">780</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Ball radius</div>
        <input id="slBallR" type="range" min="6" max="12" value="9" />
        <span id="lblBallR">9</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Balls per game</div>
        <input id="slBalls" type="range" min="3" max="10" value="5" />
        <span id="lblBallsPer">5</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Bucket speed</div>
        <input id="slBucketSpeed" type="range" min="80" max="400" value="220" />
        <span id="lblBucketSpeed">220</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Bucket size</div>
        <label>W <input id="numBucketW" type="number" min="80" max="200" value="120" /></label>
        <label>H <input id="numBucketH" type="number" min="10" max="40" value="20" /></label>
        <span class="opt-note">Edge margin 24</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Columns</div>
        <input id="numCols" type="number" min="6" max="20" value="12" />
      </div>
      <div class="opt-row">
        <div class="opt-label">Rows</div>
        <input id="numRows" type="number" min="3" max="12" value="7" />
      </div>
      <div class="opt-row">
        <div class="opt-label">Peg spacing</div>
        <input id="numSpacing" type="number" min="40" max="100" value="62" />
      </div>
      <div class="opt-row">
        <div class="opt-label">Peg radius</div>
        <input id="numPegR" type="number" min="8" max="20" value="12" />
      </div>
      <div class="opt-row">
        <div class="opt-label">Start Y</div>
        <input id="numStartY" type="number" min="50" max="300" value="150" />
      </div>
      <div class="opt-row">
        <div class="opt-label">Target ratio</div>
        <input id="slTargetRatio" type="range" min="0.10" max="0.40" step="0.01" value="0.22" />
        <span id="lblTargetRatio">22%</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Seed</div>
        <input id="txtSeed" type="text" value="" size="8" />
        <button id="btnSeed">Use</button>
      </div>
      <div class="opt-row">
        <div class="opt-label">Normal peg score</div>
        <input id="slScoreNormal" type="range" min="10" max="200" value="50" />
        <span id="lblScoreNormal">50</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Target peg score</div>
        <input id="slScoreTarget" type="range" min="50" max="300" value="150" />
        <span id="lblScoreTarget">150</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Streak step</div>
        <input id="slStreakStep" type="range" min="0.05" max="0.25" step="0.01" value="0.12" />
        <span id="lblStreakStep">0.12</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Catch bonus</div>
        <select id="selCatchBonus">
          <option value="ball">Ball</option>
          <option value="points">Points</option>
          <option value="both">Both</option>
        </select>
      </div>
      <div class="opt-row">
        <div class="opt-label">Particle density</div>
        <input id="slPartDensity" type="range" min="0" max="3" step="0.1" value="1" />
        <span id="lblPartDensity">1.0</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Particle speed</div>
        <label>Min <input id="numPartSpMin" type="number" min="0" max="400" value="80" /></label>
        <label>Max <input id="numPartSpMax" type="number" min="0" max="400" value="240" /></label>
      </div>
      <div class="opt-row">
        <div class="opt-label">Particle life</div>
        <label>Min <input id="numPartLifeMin" type="number" min="100" max="1000" value="280" /></label>
        <label>Max <input id="numPartLifeMax" type="number" min="100" max="1000" value="520" /></label>
      </div>
      <div class="opt-row">
        <div class="opt-label">Particle gravity</div>
        <input id="slPartGrav" type="range" min="0" max="1" step="0.01" value="0.62" />
        <span id="lblPartGrav">0.62</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">Trail length</div>
        <input id="slTrail" type="range" min="0" max="48" value="24" />
        <span id="lblTrail">24</span>
      </div>
      <div class="opt-row">
        <div class="opt-label">DPR cap</div>
        <select id="selDpr">
          <option value="1">1.0</option>
          <option value="1.5">1.5</option>
          <option value="2" selected>2.0</option>
        </select>
      </div>
      <div class="opt-row">
        <div class="opt-label">Color blind palette</div>
        <div class="seg" id="segColorBlind">
          <button data-v="0" class="active">Off</button>
          <button data-v="1">On</button>
        </div>
      </div>
    </div>
    <div class="footer">Single-file build • Fixed-step physics • No network</div>
    <script>
    (() => {
      'use strict';

      // -------- Utilities --------
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const TAU = Math.PI * 2;

      class RNG { // Mulberry32
        constructor(seed = 0x9e3779b9) { this.s = seed >>> 0; }
        next() { let t = this.s += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }
        range(a, b) { return a + (b - a) * this.next(); }
        pick(arr) { return arr[(this.next() * arr.length) | 0]; }
      }

      class Vec2 {
        constructor(x=0, y=0) { this.x=x; this.y=y; }
        set(x,y){ this.x=x; this.y=y; return this; }
        copy(v){ this.x=v.x; this.y=v.y; return this; }
        add(v){ this.x+=v.x; this.y+=v.y; return this; }
        sub(v){ this.x-=v.x; this.y-=v.y; return this; }
        scl(s){ this.x*=s; this.y*=s; return this; }
        len(){ return Math.hypot(this.x, this.y); }
        nrm(){ const l=this.len()||1; this.x/=l; this.y/=l; return this; }
        dot(v){ return this.x*v.x + this.y*v.y; }
        clone(){ return new Vec2(this.x, this.y); }
      }

      // -------- Rendering & Scaling --------
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const world = { w: 960, h: 540 };
      let view = { w: 0, h: 0, scale: 1, offX: 0, offY: 0 };
      function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, opts.dprCap);
        const W = window.innerWidth, H = window.innerHeight;
        const scale = Math.min(W / world.w, H / world.h);
        const w = Math.round(world.w * scale), h = Math.round(world.h * scale);
        view = { w, h, scale, offX: (W - w) >> 1, offY: (H - h) >> 1 };
        canvas.width = Math.max(1, Math.round(w * dpr));
        canvas.height = Math.max(1, Math.round(h * dpr));
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      // -------- Game State --------
      const rng = new RNG(0x1234cafe);
      const pegs = []; // {x,y,r,type:'normal'|'target', hit:boolean, glow:number}
      const particles = []; // pooled
      const trail = []; // recent positions for ball trail

      const opts = {
        guide: { on: true, bounces: 0, ms: 2000, density: 4, fadeStart: 0.6, fadeEnd: 0.12 },
        gravity: 1200,
        restitution: { ball: 0.96, peg: 0.94, wall: 0.90 },
        airDrag: 0.999,
        timeStep: 120,
        launchSpeed: 780,
        ballRadius: 9,
        ballsPerGame: 5,
        bucket: { w: 120, h: 20, speed: 220 },
        level: { cols: 12, rows: 7, spacing: 62, pegRadius: 12, startY: 150, targetRatio: 0.22, seed: 0x1234cafe },
        scoring: { normal: 50, target: 150, streakStep: 0.12, catchBonus: 'ball', catchPoints: 500 },
        particles: { density: 1, speedMin: 80, speedMax: 240, lifeMin: 280, lifeMax: 520, gravity: 0.62 },
        trailLength: 24,
        dprCap: 2,
        colorBlind: false,
      };
      let DT = 1000 / opts.timeStep; // ms per physics step
      let BALL_R = opts.ballRadius;
      let MAX_TRAIL = opts.trailLength;
      const MAX_CATCH_UP = 2; // max physics steps per frame
      const presets = [
        { name:'Classic Balanced', desc:'Default feel: 5 balls, moderate gravity, 1-bounce guide.', gravity:1200, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:780, ballRadius:9, balls:5,
          bucket:{w:120,h:20,speed:220}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.22}, guide:{bounces:1, ms:2000, density:4},
          scoring:{normal:50,target:150,streakStep:0.12,catchBonus:'ball'}, particles:{scale:1} },
        { name:'Beginner Friendly', desc:'Easier run: 8 balls, larger bucket, more targets, 3-bounce guide.', gravity:1000, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:780, ballRadius:9, balls:8,
          bucket:{w:140,h:24,speed:200}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.30}, guide:{bounces:3, ms:2000, density:4},
          scoring:{normal:50,target:150,streakStep:0.12,catchBonus:'ball'}, particles:{scale:1} },
        { name:'Skill Shot', desc:'Harder: high gravity, smaller bucket, fewer targets, no guide bounces.', gravity:1400, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:760, ballRadius:9, balls:5,
          bucket:{w:110,h:18,speed:240}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.18}, guide:{bounces:0, ms:2000, density:4},
          scoring:{normal:50,target:150,streakStep:0.12,catchBonus:'ball'}, particles:{scale:1} },
        { name:'Zen Chill', desc:'Relaxed: lower gravity, slower bucket, extra-long aim guide.', gravity:900, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:780, ballRadius:9, balls:7,
          bucket:{w:120,h:20,speed:180}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.22}, guide:{bounces:1, ms:3000, density:4},
          scoring:{normal:50,target:150,streakStep:0.12,catchBonus:'ball'}, particles:{scale:0.5} },
        { name:'Pinball Chaos', desc:'Wild bounces: near-elastic collisions for hectic ricochets.', gravity:1300, restitution:{ball:0.99,peg:0.99,wall:0.99}, launchSpeed:780, ballRadius:9, balls:5,
          bucket:{w:120,h:20,speed:260}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.22}, guide:{bounces:2, ms:2000, density:4},
          scoring:{normal:50,target:150,streakStep:0.12,catchBonus:'ball'}, particles:{scale:2} },
        { name:'Moon Walk', desc:'Low gravity with faster launch speed; floaty arcs, 3-bounce guide.', gravity:650, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:900, ballRadius:9, balls:5,
          bucket:{w:120,h:20,speed:180}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.22}, guide:{bounces:3, ms:2000, density:4},
          scoring:{normal:50,target:150,streakStep:0.12,catchBonus:'ball'}, particles:{scale:1} },
        { name:'Speedrunner', desc:'Fast and lean: 3 balls, quick bucket, minimal targets.', gravity:1200, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:780, ballRadius:9, balls:3,
          bucket:{w:120,h:20,speed:280}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.25}, guide:{bounces:0, ms:2000, density:4},
          scoring:{normal:50,target:150,streakStep:0.12,catchBonus:'ball'}, particles:{scale:1} },
        { name:'Pachinko Flood', desc:'Dense grid: more rows and columns, slightly smaller pegs.', gravity:1200, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:780, ballRadius:9, balls:5,
          bucket:{w:120,h:20,speed:220}, grid:{cols:14,rows:9,spacing:54,r:11,startY:150,targetRatio:0.20}, guide:{bounces:1, ms:2000, density:4},
          scoring:{normal:50,target:150,streakStep:0.12,catchBonus:'ball'}, particles:{scale:1} },
        { name:'Tiny Ball, Tiny Bucket', desc:'Precision mode: smaller ball and bucket; tighter gaps.', gravity:1200, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:780, ballRadius:7, balls:5,
          bucket:{w:100,h:18,speed:230}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.22}, guide:{bounces:2, ms:2000, density:4},
          scoring:{normal:50,target:150,streakStep:0.12,catchBonus:'ball'}, particles:{scale:1} },
        { name:'Jumbo Party', desc:'Chunky fun: bigger ball and bucket; forgiving ricochets.', gravity:1200, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:780, ballRadius:12, balls:5,
          bucket:{w:140,h:24,speed:220}, grid:{cols:12,rows:7,spacing:68,r:14,startY:150,targetRatio:0.22}, guide:{bounces:1, ms:2000, density:4},
          scoring:{normal:50,target:150,streakStep:0.20,catchBonus:'ball'}, particles:{scale:2} },
        { name:'Gremlin Mode', desc:'Mischief enabled: unexpected antics for chaotic runs.', gravity:1200, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:780, ballRadius:9, balls:5,
          bucket:{w:120,h:20,speed:220}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.22}, guide:{bounces:1, ms:2000, density:4},
          scoring:{normal:50,target:150,streakStep:0.12,catchBonus:'ball'}, particles:{scale:1}, fun:{gremlin:true} },
        { name:'Billionaire Mode', desc:'Make it rain: huge points, more targets, catch gives points.', gravity:1200, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:780, ballRadius:9, balls:5,
          bucket:{w:120,h:20,speed:220}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.35}, guide:{bounces:1, ms:2000, density:4},
          scoring:{normal:500,target:1500,streakStep:0.24,catchBonus:'points'}, particles:{scale:3} },
        { name:'One-Shot Hero', desc:'One ball only; larger bucket and 3-bounce guide—make it count.', gravity:1100, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:780, ballRadius:9, balls:1,
          bucket:{w:160,h:26,speed:200}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.22}, guide:{bounces:3, ms:2000, density:4},
          scoring:{normal:100,target:300,streakStep:0.12,catchBonus:'ball'}, particles:{scale:1} },
        { name:'Kids Party', desc:'Lots of balls, big bucket, more targets; confetti galore.', gravity:900, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:780, ballRadius:9, balls:12,
          bucket:{w:180,h:26,speed:180}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.30}, guide:{bounces:3, ms:2000, density:4},
          scoring:{normal:50,target:150,streakStep:0.12,catchBonus:'ball'}, particles:{scale:2}, fun:{confetti:true} },
        { name:'Hardcore Purist', desc:'Tough mode: high gravity, small bucket, 0-bounce guide.', gravity:1300, restitution:{ball:0.96,peg:0.94,wall:0.90}, launchSpeed:780, ballRadius:9, balls:3,
          bucket:{w:110,h:18,speed:260}, grid:{cols:12,rows:7,spacing:62,r:12,startY:150,targetRatio:0.25}, guide:{bounces:0, ms:2000, density:4},
          scoring:{normal:50,target:150,streakStep:0.12,catchBonus:'ball'}, particles:{scale:1} },
      ];
      opts.presets = presets;

      let bucket = { x: world.w * 0.5, y: world.h - 36, dir: 1, w: opts.bucket.w, h: opts.bucket.h, speed: opts.bucket.speed };
      let ball = { pos: new Vec2(world.w*0.5, 80), vel: new Vec2(0,0), alive: false };
      let ballsLeft = opts.ballsPerGame;
      let score = 0;
      let streak = 0;
      let targetsLeft = 0;
      let state = 'aim'; // 'aim' | 'fly' | 'win' | 'lose'
      let accumulator = 0; let lastT = performance.now();

      // HUD elements
      const hudScore = document.getElementById('score');
      const hudBalls = document.getElementById('balls');
      const hudTargets = document.getElementById('targets');
      const hudStreak = document.getElementById('streak');
      const btnRestart = document.getElementById('btnRestart');
      
      const btnOptions = document.getElementById('btnOptions');
      const optionsPanel = document.getElementById('optionsPanel');
      const segGuideOn = document.getElementById('segGuideOn');
      const segBounces = document.getElementById('segBounces');
      const slGravity = document.getElementById('slGravity');
      const lblGravity = document.getElementById('lblGravity');
      const slRestBall = document.getElementById('slRestBall');
      const slRestPeg = document.getElementById('slRestPeg');
      const slRestWall = document.getElementById('slRestWall');
      const slDrag = document.getElementById('slDrag');
      const lblDrag = document.getElementById('lblDrag');
      const selHz = document.getElementById('selHz');
      const slLaunch = document.getElementById('slLaunch');
      const lblLaunch = document.getElementById('lblLaunch');
      const slBallR = document.getElementById('slBallR');
      const lblBallR = document.getElementById('lblBallR');
      const slBalls = document.getElementById('slBalls');
      const lblBallsPer = document.getElementById('lblBallsPer');
      const slBucketSpeed = document.getElementById('slBucketSpeed');
      const lblBucketSpeed = document.getElementById('lblBucketSpeed');
      const numBucketW = document.getElementById('numBucketW');
      const numBucketH = document.getElementById('numBucketH');
      const slGuideMs = document.getElementById('slGuideMs');
      const lblGuideMs = document.getElementById('lblGuideMs');
      const slGuideDensity = document.getElementById('slGuideDensity');
      const lblGuideDensity = document.getElementById('lblGuideDensity');
      const slGuideFadeStart = document.getElementById('slGuideFadeStart');
      const slGuideFadeEnd = document.getElementById('slGuideFadeEnd');
      const numCols = document.getElementById('numCols');
      const numRows = document.getElementById('numRows');
      const numSpacing = document.getElementById('numSpacing');
      const numPegR = document.getElementById('numPegR');
      const numStartY = document.getElementById('numStartY');
      const slTargetRatio = document.getElementById('slTargetRatio');
      const lblTargetRatio = document.getElementById('lblTargetRatio');
      const txtSeed = document.getElementById('txtSeed');
      const btnSeed = document.getElementById('btnSeed');
      const slScoreNormal = document.getElementById('slScoreNormal');
      const lblScoreNormal = document.getElementById('lblScoreNormal');
      const slScoreTarget = document.getElementById('slScoreTarget');
      const lblScoreTarget = document.getElementById('lblScoreTarget');
      const slStreakStep = document.getElementById('slStreakStep');
      const lblStreakStep = document.getElementById('lblStreakStep');
      const selCatchBonus = document.getElementById('selCatchBonus');
      const slPartDensity = document.getElementById('slPartDensity');
      const lblPartDensity = document.getElementById('lblPartDensity');
      const numPartSpMin = document.getElementById('numPartSpMin');
      const numPartSpMax = document.getElementById('numPartSpMax');
      const numPartLifeMin = document.getElementById('numPartLifeMin');
      const numPartLifeMax = document.getElementById('numPartLifeMax');
      const slPartGrav = document.getElementById('slPartGrav');
      const lblPartGrav = document.getElementById('lblPartGrav');
      const slTrail = document.getElementById('slTrail');
      const lblTrail = document.getElementById('lblTrail');
      const selDpr = document.getElementById('selDpr');
      const segColorBlind = document.getElementById('segColorBlind');
      const selPreset = document.getElementById('selPreset');

      // Tooltips for settings
      selPreset.title = 'Choose a preset configuration';
      segGuideOn.title = 'Toggle the aiming guide visualization';
      segBounces.title = 'How many predicted bounces to show in the guide';
      slGuideMs.title = 'Maximum simulated time for the guide (ms)';
      slGuideDensity.title = 'Breadcrumb spacing for the guide (higher = denser)';
      slGuideFadeStart.title = 'Starting opacity of guide breadcrumbs';
      slGuideFadeEnd.title = 'Ending opacity of guide breadcrumbs';

      slGravity.title = 'Downward acceleration (higher = faster fall)';
      slRestBall.title = 'Ball bounciness on impact';
      slRestPeg.title = 'Peg bounciness on impact';
      slRestWall.title = 'Wall bounciness on impact';
      slDrag.title = 'Air resistance per tick (closer to 1 = less drag)';
      selHz.title = 'Physics steps per second (higher = smoother, more CPU)';

      slLaunch.title = 'Initial speed when firing the ball';
      slBallR.title = 'Ball radius in pixels';
      slBalls.title = 'Number of balls for the current game';

      slBucketSpeed.title = 'Horizontal movement speed of the bucket';
      numBucketW.title = 'Bucket opening width in pixels';
      numBucketH.title = 'Bucket height in pixels';

      numCols.title = 'Number of peg columns in the grid';
      numRows.title = 'Number of peg rows in the grid';
      numSpacing.title = 'Horizontal spacing between peg columns';
      numPegR.title = 'Peg radius in pixels';
      numStartY.title = 'Vertical start position for the first peg row';
      slTargetRatio.title = 'Fraction of pegs that are orange targets';
      txtSeed.title = 'Hex seed for deterministic level generation';
      btnSeed.title = 'Regenerate layout using the given seed';

      slScoreNormal.title = 'Score awarded for hitting a normal (blue) peg';
      slScoreTarget.title = 'Score awarded for hitting a target (orange) peg';
      slStreakStep.title = 'Per-hit multiplier step added to streak bonus';
      selCatchBonus.title = 'Reward when the ball lands in the bucket';

      slPartDensity.title = 'Particle effect density multiplier';
      numPartSpMin.title = 'Minimum particle speed on emission';
      numPartSpMax.title = 'Maximum particle speed on emission';
      numPartLifeMin.title = 'Minimum particle lifetime (ms)';
      numPartLifeMax.title = 'Maximum particle lifetime (ms)';
      slPartGrav.title = 'Particle gravity factor relative to ball gravity';

      slTrail.title = 'Number of trail dots drawn behind the ball';
      selDpr.title = 'Maximum device pixel ratio (performance cap)';
      segColorBlind.title = 'Use a color-blind friendly palette';

      function syncOptionsUI() {
        slGravity.value = String(opts.gravity);
        lblGravity.textContent = String(opts.gravity);
        slRestBall.value = String(opts.restitution.ball);
        slRestPeg.value = String(opts.restitution.peg);
        slRestWall.value = String(opts.restitution.wall);
        slDrag.value = String(opts.airDrag);
        lblDrag.textContent = opts.airDrag.toFixed(3);
        selHz.value = String(opts.timeStep);
        slLaunch.value = String(opts.launchSpeed);
        lblLaunch.textContent = String(opts.launchSpeed);
        slBallR.value = String(opts.ballRadius);
        lblBallR.textContent = String(opts.ballRadius);
        slBalls.value = String(opts.ballsPerGame);
        lblBallsPer.textContent = String(opts.ballsPerGame);
        slBucketSpeed.value = String(opts.bucket.speed);
        lblBucketSpeed.textContent = String(opts.bucket.speed);
        numBucketW.value = String(opts.bucket.w);
        numBucketH.value = String(opts.bucket.h);
        slGuideMs.value = String(opts.guide.ms);
        lblGuideMs.textContent = String(opts.guide.ms);
        slGuideDensity.value = String(opts.guide.density);
        lblGuideDensity.textContent = String(opts.guide.density);
        slGuideFadeStart.value = String(opts.guide.fadeStart);
        slGuideFadeEnd.value = String(opts.guide.fadeEnd);
        numCols.value = String(opts.level.cols);
        numRows.value = String(opts.level.rows);
        numSpacing.value = String(opts.level.spacing);
        numPegR.value = String(opts.level.pegRadius);
        numStartY.value = String(opts.level.startY);
        slTargetRatio.value = String(opts.level.targetRatio.toFixed(2));
        lblTargetRatio.textContent = `${Math.round(opts.level.targetRatio*100)}%`;
        txtSeed.value = opts.level.seed.toString(16);
        slScoreNormal.value = String(opts.scoring.normal);
        lblScoreNormal.textContent = String(opts.scoring.normal);
        slScoreTarget.value = String(opts.scoring.target);
        lblScoreTarget.textContent = String(opts.scoring.target);
        slStreakStep.value = String(opts.scoring.streakStep);
        lblStreakStep.textContent = opts.scoring.streakStep.toFixed(2);
        selCatchBonus.value = opts.scoring.catchBonus;
        slPartDensity.value = String(opts.particles.density);
        lblPartDensity.textContent = Number(opts.particles.density).toFixed(1);
        numPartSpMin.value = String(opts.particles.speedMin);
        numPartSpMax.value = String(opts.particles.speedMax);
        numPartLifeMin.value = String(opts.particles.lifeMin);
        numPartLifeMax.value = String(opts.particles.lifeMax);
        slPartGrav.value = String(opts.particles.gravity);
        lblPartGrav.textContent = opts.particles.gravity.toFixed(2);
        slTrail.value = String(opts.trailLength);
        lblTrail.textContent = String(opts.trailLength);
        selDpr.value = String(opts.dprCap);
        Array.from(segGuideOn.children).forEach(ch => ch.classList.toggle('active', (ch.dataset.on==='1') === opts.guide.on));
        Array.from(segBounces.children).forEach(ch => ch.classList.toggle('active', parseInt(ch.dataset.v,10) === opts.guide.bounces));
        segBounces.classList.toggle('disabled', !opts.guide.on);
        Array.from(segColorBlind.children).forEach(ch => ch.classList.toggle('active', (ch.dataset.v==='1') === opts.colorBlind));
      }
      syncOptionsUI();

      function resetLevel(seed = opts.level.seed) {
        opts.level.seed = seed >>> 0;
        rng.s = opts.level.seed;
        pegs.length = 0; particles.length = 0; trail.length = 0;
        // Layout: hex grid cluster
        const { cols, rows, spacing, pegRadius: r, startY, targetRatio } = opts.level;
        const startX = (world.w - (cols-1) * spacing) * 0.5;
        const targetIndices = new Set();
        // pick targets
        const total = cols * rows; const targetCount = Math.round(total * targetRatio);
        while (targetIndices.size < targetCount) targetIndices.add((rng.next()*total)|0);
        let idx = 0;
        for (let j=0;j<rows;j++) {
          for (let i=0;i<cols;i++) {
            const x = startX + i*spacing + (j%2 ? spacing*0.5 : 0);
            const y = startY + j*spacing*0.86;
            if (x < 60 || x > world.w-60) continue; // trim edges
            const type = targetIndices.has(idx) ? 'target' : 'normal';
            pegs.push({ x, y, r, type, hit:false, glow:0 });
            idx++;
          }
        }
        targetsLeft = pegs.filter(p=>p.type==='target').length;
        bucket = { x: world.w*0.5, y: world.h-36, w: opts.bucket.w, h: opts.bucket.h, speed: opts.bucket.speed, dir: 1 };
        ball.pos.set(world.w*0.5, 80); ball.vel.set(0,0); ball.alive=false;
        ballsLeft = opts.ballsPerGame; score = 0; streak = 0; state='aim';
        updateHUD();
        // Initialize options UI state
        updateBouncesEnabled();
        txtSeed.value = opts.level.seed.toString(16);
      }

      function updateHUD() {
        hudScore.textContent = String(score);
        hudBalls.textContent = String(ballsLeft);
        hudTargets.textContent = String(targetsLeft);
        hudStreak.textContent = String(streak);
      }

      

      // -------- Input & Aiming --------
      const pointer = { x: world.w*0.5, y: 200, down:false };
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const sx = (e.clientX - rect.left) / rect.width;
        const sy = (e.clientY - rect.top) / rect.height;
        pointer.x = world.w * sx;
        pointer.y = world.h * sy;
      });
      canvas.addEventListener('mousedown', () => { pointer.down = true; });
      canvas.addEventListener('mouseup', () => { pointer.down = false; });
      window.addEventListener('blur', ()=> pointer.down=false);
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') { shoot(); }
        if (e.key === 'o' || e.key === 'O') { optionsPanel.hidden = !optionsPanel.hidden; }
      });
      btnRestart.addEventListener('click', () => { resetLevel((Math.random()*0xffffffff)>>>0); });
      btnOptions.addEventListener('click', () => { optionsPanel.hidden = !optionsPanel.hidden; });
      function updateBouncesEnabled() {
        segBounces.classList.toggle('disabled', !opts.guide.on);
      }
      segGuideOn.addEventListener('click', (e) => {
        const b = e.target.closest('button'); if (!b) return;
        const on = b.dataset.on === '1';
        opts.guide.on = on;
        Array.from(segGuideOn.children).forEach(ch => ch.classList.toggle('active', ch === b));
        if (!opts.guide.on) {
          // when off, also clear bounce selection
          opts.guide.bounces = 0;
          Array.from(segBounces.children).forEach(ch => ch.classList.remove('active'));
        }
        updateBouncesEnabled();
      });
      segBounces.addEventListener('click', (e) => {
        const b = e.target.closest('button'); if (!b) return;
        const val = parseInt(b.dataset.v, 10);
        const isActive = b.classList.contains('active');
        // Toggle off if clicking the active one
        if (isActive) {
          opts.guide.bounces = 0;
          Array.from(segBounces.children).forEach(ch => ch.classList.remove('active'));
        } else {
          opts.guide.bounces = val;
          Array.from(segBounces.children).forEach(ch => ch.classList.toggle('active', ch === b));
        }
      });

      slGravity.addEventListener('input', () => {
        opts.gravity = Number(slGravity.value);
        lblGravity.textContent = slGravity.value;
      });
      slRestBall.addEventListener('input', () => { opts.restitution.ball = Number(slRestBall.value); });
      slRestPeg.addEventListener('input', () => { opts.restitution.peg = Number(slRestPeg.value); });
      slRestWall.addEventListener('input', () => { opts.restitution.wall = Number(slRestWall.value); });
      slDrag.addEventListener('input', () => {
        opts.airDrag = Number(slDrag.value);
        lblDrag.textContent = Number(slDrag.value).toFixed(3);
      });
      selHz.addEventListener('change', () => {
        opts.timeStep = Number(selHz.value);
        DT = 1000 / opts.timeStep;
      });
      slLaunch.addEventListener('input', () => {
        opts.launchSpeed = Number(slLaunch.value);
        lblLaunch.textContent = slLaunch.value;
      });
      slBallR.addEventListener('input', () => {
        opts.ballRadius = Number(slBallR.value);
        BALL_R = opts.ballRadius;
        lblBallR.textContent = slBallR.value;
      });
      slBalls.addEventListener('input', () => {
        opts.ballsPerGame = Number(slBalls.value);
        lblBallsPer.textContent = slBalls.value;
        ballsLeft = opts.ballsPerGame;
        updateHUD();
      });
      slBucketSpeed.addEventListener('input', () => {
        opts.bucket.speed = Number(slBucketSpeed.value);
        bucket.speed = opts.bucket.speed; // reflect live in-game
        lblBucketSpeed.textContent = slBucketSpeed.value;
      });
      numBucketW.addEventListener('input', () => {
        opts.bucket.w = Number(numBucketW.value);
        bucket.w = opts.bucket.w;
      });
      numBucketH.addEventListener('input', () => {
        opts.bucket.h = Number(numBucketH.value);
        bucket.h = opts.bucket.h;
      });
      slGuideMs.addEventListener('input', () => {
        opts.guide.ms = Number(slGuideMs.value);
        lblGuideMs.textContent = slGuideMs.value;
      });
      slGuideDensity.addEventListener('input', () => {
        opts.guide.density = Number(slGuideDensity.value);
        lblGuideDensity.textContent = slGuideDensity.value;
      });
      slGuideFadeStart.addEventListener('input', () => { opts.guide.fadeStart = Number(slGuideFadeStart.value); });
      slGuideFadeEnd.addEventListener('input', () => { opts.guide.fadeEnd = Number(slGuideFadeEnd.value); });
      // Debounced level regeneration for generation-affecting settings
      let resetTimer = null;
      function scheduleLevelReset() {
        if (resetTimer) clearTimeout(resetTimer);
        resetTimer = setTimeout(() => { resetLevel(opts.level.seed); }, 300);
      }
      numCols.addEventListener('input', () => { opts.level.cols = Number(numCols.value); scheduleLevelReset(); });
      numRows.addEventListener('input', () => { opts.level.rows = Number(numRows.value); scheduleLevelReset(); });
      numSpacing.addEventListener('input', () => { opts.level.spacing = Number(numSpacing.value); scheduleLevelReset(); });
      numPegR.addEventListener('input', () => { opts.level.pegRadius = Number(numPegR.value); scheduleLevelReset(); });
      numStartY.addEventListener('input', () => { opts.level.startY = Number(numStartY.value); scheduleLevelReset(); });
      slTargetRatio.addEventListener('input', () => { opts.level.targetRatio = Number(slTargetRatio.value); lblTargetRatio.textContent = `${Math.round(opts.level.targetRatio*100)}%`; scheduleLevelReset(); });
      btnSeed.addEventListener('click', () => { const val = parseInt(txtSeed.value, 16); if (!Number.isNaN(val)) resetLevel(val >>> 0); });
      txtSeed.addEventListener('keydown', (e) => { if (e.key === 'Enter') { const v = parseInt(txtSeed.value, 16); if (!Number.isNaN(v)) resetLevel(v >>> 0); }});
      slScoreNormal.addEventListener('input', () => { opts.scoring.normal = Number(slScoreNormal.value); lblScoreNormal.textContent = slScoreNormal.value; });
      slScoreTarget.addEventListener('input', () => { opts.scoring.target = Number(slScoreTarget.value); lblScoreTarget.textContent = slScoreTarget.value; });
      slStreakStep.addEventListener('input', () => { opts.scoring.streakStep = Number(slStreakStep.value); lblStreakStep.textContent = Number(slStreakStep.value).toFixed(2); });
      selCatchBonus.addEventListener('change', () => { opts.scoring.catchBonus = selCatchBonus.value; });
      slPartDensity.addEventListener('input', () => { opts.particles.density = Number(slPartDensity.value); lblPartDensity.textContent = Number(slPartDensity.value).toFixed(1); });
      numPartSpMin.addEventListener('input', () => { opts.particles.speedMin = Number(numPartSpMin.value); });
      numPartSpMax.addEventListener('input', () => { opts.particles.speedMax = Number(numPartSpMax.value); });
      numPartLifeMin.addEventListener('input', () => { opts.particles.lifeMin = Number(numPartLifeMin.value); });
      numPartLifeMax.addEventListener('input', () => { opts.particles.lifeMax = Number(numPartLifeMax.value); });
      slPartGrav.addEventListener('input', () => { opts.particles.gravity = Number(slPartGrav.value); lblPartGrav.textContent = slPartGrav.value; });
      slTrail.addEventListener('input', () => { opts.trailLength = Number(slTrail.value); MAX_TRAIL = opts.trailLength; lblTrail.textContent = slTrail.value; });
      selDpr.addEventListener('change', () => { opts.dprCap = Number(selDpr.value); resize(); });
      segColorBlind.addEventListener('click', (e) => {
        const b = e.target.closest('button'); if (!b) return;
        const val = b.dataset.v === '1';
        opts.colorBlind = val;
        Array.from(segColorBlind.children).forEach(ch => ch.classList.toggle('active', ch === b));
      });
      // add options with hover descriptions
      // add a title for the Custom entry
      selPreset.querySelector('option[value=""]').title = 'Custom settings (not a saved preset)';
      presets.forEach((p,i)=>{
        const o = document.createElement('option');
        o.value = String(i);
        o.textContent = p.name;
        if (p.desc) o.title = p.desc;
        selPreset.appendChild(o);
      });
      // keep the select's title in sync with the current choice for better hover UX
      function syncPresetTitle() {
        const opt = selPreset.options[selPreset.selectedIndex];
        selPreset.title = opt && opt.title ? opt.title : '';
      }
      syncPresetTitle();
      function applyPreset(p){
        opts.gravity = p.gravity;
        opts.restitution = { ...p.restitution };
        opts.launchSpeed = p.launchSpeed;
        opts.ballRadius = p.ballRadius; BALL_R = opts.ballRadius;
        opts.ballsPerGame = p.balls; ballsLeft = opts.ballsPerGame;
        opts.bucket = { ...p.bucket };
        Object.assign(opts.level, { cols:p.grid.cols, rows:p.grid.rows, spacing:p.grid.spacing, pegRadius:p.grid.r, startY:p.grid.startY, targetRatio:p.grid.targetRatio });
        Object.assign(opts.guide, { bounces:p.guide.bounces, ms:p.guide.ms, density:p.guide.density });
        Object.assign(opts.scoring, { normal:p.scoring.normal, target:p.scoring.target, streakStep:p.scoring.streakStep, catchBonus:p.scoring.catchBonus });
        opts.particles.density = p.particles.scale;
        syncOptionsUI();
        resetLevel(opts.level.seed);
      }
      selPreset.addEventListener('change', () => {
        const idx = parseInt(selPreset.value,10);
        if (!isNaN(idx)) applyPreset(presets[idx]);
        syncPresetTitle();
      });

      function shoot() {
        if (state !== 'aim' || ballsLeft <= 0) return;
        const dir = Math.atan2(pointer.y - ball.pos.y, pointer.x - ball.pos.x);
        const speed = opts.launchSpeed;
        ball.vel.set(Math.cos(dir)*speed, Math.sin(dir)*speed);
        ball.alive = true; state = 'fly'; streak = 0; trail.length = 0;
        // no HUD messages
      }

      canvas.addEventListener('click', shoot);

      // -------- Particles --------
      function emitHit(x, y, color) {
        const count = Math.round(14 * opts.particles.density);
        for (let i=0;i<count;i++) {
          const a = rng.range(0, TAU);
          const sp = rng.range(opts.particles.speedMin, opts.particles.speedMax);
          particles.push({ x, y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: rng.range(opts.particles.lifeMin, opts.particles.lifeMax), age: 0, c: color });
        }
      }

      function stepParticles(dt) {
        for (let i=particles.length-1;i>=0;i--) {
          const p = particles[i];
          p.age += dt; if (p.age >= p.life) { particles.splice(i,1); continue; }
          p.vx *= 0.992; p.vy = p.vy*0.992 + opts.gravity * opts.particles.gravity * (dt/1000);
          p.x += p.vx * dt/1000; p.y += p.vy * dt/1000;
        }
      }

      // -------- Physics --------
      function reflectVelocity(vx, vy, nx, ny, rest) {
        const dot = vx*nx + vy*ny;
        const rx = vx - (1+rest) * dot * nx;
        const ry = vy - (1+rest) * dot * ny;
        return [rx, ry];
      }

      function circleCollide(x,y,r, px,py,pr) { // returns normal & penetration
        const dx = x-px, dy = y-py; const d2 = dx*dx + dy*dy; const rr = (r+pr)*(r+pr);
        if (d2 >= rr) return null; const d = Math.sqrt(d2)||1; const nx = dx/d, ny = dy/d; const pen = (r+pr)-d; return { nx, ny, pen };
      }

      function stepBucket(dt) {
        bucket.x += bucket.dir * bucket.speed * dt/1000;
        const margin = 24;
        if (bucket.x - bucket.w*0.5 < margin) { bucket.x = margin + bucket.w*0.5; bucket.dir = 1; }
        if (bucket.x + bucket.w*0.5 > world.w - margin) { bucket.x = world.w - margin - bucket.w*0.5; bucket.dir = -1; }
      }

      function stepBall(dt) {
        if (!ball.alive) return;
        // increase substeps based on speed to mitigate tunneling
        const speed = ball.vel.len();
        const sub = Math.min(4, 1 + ((speed > 800) ? 2 : 0));
        const sdt = dt / sub;
        for (let k=0;k<sub;k++) {
          // integrate
          ball.vel.y += opts.gravity * (sdt/1000);
          ball.vel.x *= opts.airDrag; ball.vel.y *= opts.airDrag;
          ball.pos.x += ball.vel.x * sdt/1000;
          ball.pos.y += ball.vel.y * sdt/1000;

          // walls
          if (ball.pos.x < BALL_R) { ball.pos.x = BALL_R; ball.vel.x = Math.abs(ball.vel.x)*opts.restitution.wall; }
          if (ball.pos.x > world.w-BALL_R) { ball.pos.x = world.w-BALL_R; ball.vel.x = -Math.abs(ball.vel.x)*opts.restitution.wall; }
          if (ball.pos.y < BALL_R) { ball.pos.y = BALL_R; ball.vel.y = Math.abs(ball.vel.y)*opts.restitution.wall; }

          // bucket catch (sensor at top of bucket)
          const withinX = Math.abs(ball.pos.x - bucket.x) < (bucket.w*0.5 - BALL_R*0.5);
          const nearTop = ball.pos.y > bucket.y - bucket.h*0.5 - BALL_R && ball.pos.y < bucket.y + bucket.h*0.2;
          if (withinX && nearTop && ball.vel.y > 0) {
            emitHit(ball.pos.x, ball.pos.y, '#ffd166');
            if (opts.scoring.catchBonus === 'ball' || opts.scoring.catchBonus === 'both') {
              ballsLeft++; updateHUD();
            }
            if (opts.scoring.catchBonus === 'points' || opts.scoring.catchBonus === 'both') {
              score += opts.scoring.catchPoints; updateHUD();
            }
            ball.alive = false; state = (targetsLeft<=0) ? 'win' : 'aim';
            ball.pos.set(world.w*0.5, 80); ball.vel.set(0,0); trail.length=0; streak=0;
            // no HUD messages
            return;
          }

          // pegs
          for (let i=pegs.length-1;i>=0;i--) {
            const p = pegs[i]; if (p.hit) continue;
            const col = circleCollide(ball.pos.x, ball.pos.y, BALL_R, p.x, p.y, p.r);
            if (!col) continue;
            // resolve position
            ball.pos.x += col.nx * col.pen;
            ball.pos.y += col.ny * col.pen;
            // reflect velocity
            let [rx, ry] = reflectVelocity(ball.vel.x, ball.vel.y, col.nx, col.ny, (opts.restitution.ball + opts.restitution.peg)*0.5);
            ball.vel.set(rx, ry);
            // scoring & effects
            p.hit = true; p.glow = 1;
            const base = (p.type === 'target') ? opts.scoring.target : opts.scoring.normal;
            score += Math.round(base * (1 + streak*opts.scoring.streakStep));
            streak += 1; updateHUD();
            emitHit(p.x, p.y, p.type==='target' ? '#ff9f6e' : '#66ccff');
            if (p.type==='target') { targetsLeft--; updateHUD(); if (targetsLeft<=0) { /* win when ball finishes */ } }
          }
        }

        // floor (miss)
        if (ball.pos.y > world.h + BALL_R) {
          ballsLeft--; updateHUD();
          ball.alive = false; trail.length=0; streak=0;
          if (targetsLeft<=0) { state='win'; }
          else if (ballsLeft>0) { state='aim'; }
          else { state='lose'; }
          ball.pos.set(world.w*0.5, 80); ball.vel.set(0,0);
        }
      }

      // -------- Guide Prediction (replicates fixed-step + substeps) --------
      function computeGuide() {
        if (!opts.guide.on || state !== 'aim') return null;
        const start = ball.pos.clone();
        const dir = Math.atan2(pointer.y - start.y, pointer.x - start.x);
        const pos = start.clone();
        const vel = new Vec2(Math.cos(dir)*opts.launchSpeed, Math.sin(dir)*opts.launchSpeed);
        const maxMs = opts.guide.ms;
        let elapsed = 0;
        const pts = [pos.clone()];
        let contacts = 0; // includes walls and pegs
        let finalHit = null;
        // Simulate using the same integration and collision order as runtime
        const maxContacts = 1 + (opts.guide.bounces|0); // 0=>first contact
        outer: while (elapsed < maxMs && contacts < maxContacts) {
          const speed = vel.len();
          const sub = Math.min(4, 1 + ((speed > 800) ? 2 : 0));
          const sdt = DT / sub; // ms
          for (let k=0; k<sub; k++) {
            // integrate
            vel.y += opts.gravity * (sdt/1000);
            vel.x *= opts.airDrag; vel.y *= opts.airDrag;
            pos.x += vel.x * sdt/1000;
            pos.y += vel.y * sdt/1000;

            // walls
            let hitWall = false;
            if (pos.x < BALL_R) { pos.x = BALL_R; vel.x = Math.abs(vel.x)*opts.restitution.wall; hitWall = true; }
            if (pos.x > world.w-BALL_R) { pos.x = world.w-BALL_R; vel.x = -Math.abs(vel.x)*opts.restitution.wall; hitWall = true; }
            if (pos.y < BALL_R) { pos.y = BALL_R; vel.y = Math.abs(vel.y)*opts.restitution.wall; hitWall = true; }
            if (hitWall) {
              pts.push(pos.clone());
              contacts++;
              if (contacts >= maxContacts) break outer;
            }

            // pegs
            for (let i=pegs.length-1;i>=0;i--) {
              const p = pegs[i]; if (p.hit) continue;
              const col = circleCollide(pos.x, pos.y, BALL_R, p.x, p.y, p.r);
              if (!col) continue;
              // resolve like runtime
              pos.x += col.nx * col.pen;
              pos.y += col.ny * col.pen;
              const rv = reflectVelocity(vel.x, vel.y, col.nx, col.ny, (opts.restitution.ball + opts.restitution.peg)*0.5);
              vel.set(rv[0], rv[1]);
              contacts++;
              finalHit = { x: pos.x, y: pos.y };
              pts.push(pos.clone());
              if (contacts >= maxContacts) break outer;
              break;
            }

            pts.push(pos.clone());
            if (pos.y > world.h + BALL_R + 40) break;
          }
          elapsed += DT;
          if (pos.y > world.h + BALL_R + 40) break;
        }
        return { pts, hit: finalHit };
      }

      // -------- Render --------
      function drawPeg(p) {
        const palette = opts.colorBlind
          ? { normalBase: '#ffd400', normalEdge: '#fff1a8', normalGlow: 'rgba(255,212,0,0.25)', targetBase: '#4e79a7', targetEdge: '#a6c8ff', targetGlow: 'rgba(78,121,167,0.22)' }
          : { normalBase: '#4fc3f7', normalEdge: '#b8e7ff', normalGlow: 'rgba(79,195,247,0.22)', targetBase: '#ff7c47', targetEdge: '#ffd1bd', targetGlow: 'rgba(255,124,71,0.25)' };
        const base = p.type==='target' ? palette.targetBase : palette.normalBase;
        const edge = p.type==='target' ? palette.targetEdge : palette.normalEdge;
        const glowCol = p.type==='target' ? palette.targetGlow : palette.normalGlow;
        // glow
        {
          const g = p.hit ? p.glow : 0.25 + 0.25*Math.sin(performance.now()*0.002 + p.x*0.01);
          if (g>0) {
            const r = p.r + 10*g;
            const grad = ctx.createRadialGradient(p.x, p.y, p.r*0.2, p.x, p.y, r);
            grad.addColorStop(0, glowCol);
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, TAU); ctx.fill();
          }
        }
        // peg body
        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, TAU);
        const grad2 = ctx.createLinearGradient(p.x, p.y-p.r, p.x, p.y+p.r);
        grad2.addColorStop(0, edge); grad2.addColorStop(1, base);
        ctx.fillStyle = grad2; ctx.fill();
        // rim
        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.stroke();
        if (p.hit) { p.glow = Math.max(0, p.glow - 0.06); }
      }

      function drawBucket() {
        const x = bucket.x, y = bucket.y, w = bucket.w, h = bucket.h;
        // glow
        {
          const grad = ctx.createRadialGradient(x, y, h*0.6, x, y, w*0.8);
          grad.addColorStop(0, 'rgba(255,231,91,0.12)'); grad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grad; ctx.beginPath(); ctx.ellipse(x, y+6, w*0.7, h*1.2, 0, 0, TAU); ctx.fill();
        }
        // body
        ctx.beginPath();
        ctx.roundRect(x - w*0.5, y - h*0.5, w, h, 8);
        const grad2 = ctx.createLinearGradient(x, y-h*0.5, x, y+h*0.5);
        grad2.addColorStop(0, '#ffe75b'); grad2.addColorStop(1, '#d99a23');
        ctx.fillStyle = grad2; ctx.fill();
        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.stroke();
      }

      function drawBall() {
        // trail
        if (trail.length>1) {
          for (let i=1;i<trail.length;i++) {
            const t = i/(trail.length-1);
            const a = 0.28 * (t*t);
            ctx.beginPath(); ctx.arc(trail[i].x, trail[i].y, BALL_R*(0.6 + 0.4*t), 0, TAU);
            ctx.fillStyle = `rgba(174,209,255,${a.toFixed(3)})`; ctx.fill();
          }
        }
        // ball
        ctx.beginPath(); ctx.arc(ball.pos.x, ball.pos.y, BALL_R, 0, TAU);
        const g = ctx.createRadialGradient(ball.pos.x-3, ball.pos.y-3, BALL_R*0.2, ball.pos.x, ball.pos.y, BALL_R);
        g.addColorStop(0, '#ffffff'); g.addColorStop(1, '#8bbcff');
        ctx.fillStyle = g; ctx.fill();
        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.stroke();
      }

      function drawGuide() {
        const g = computeGuide(); if (!g) return;
        const n = g.pts.length; if (n < 2) return;
        // Draw breadcrumb dots with fade towards the end
        const startA = opts.guide.fadeStart, endA = opts.guide.fadeEnd;
        const step = Math.max(1, opts.guide.density);
        for (let i=0;i<n; i+=step) {
          const p = g.pts[i];
          const t = i/(n-1);
          const a = lerp(startA, endA, t*t);
          ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, TAU);
          ctx.fillStyle = `rgba(230,240,255,${a.toFixed(3)})`;
          ctx.fill();
        }
        // Subtle mark on final hit
        if (g.hit) {
          ctx.beginPath(); ctx.arc(g.hit.x, g.hit.y, 6, 0, TAU);
          ctx.strokeStyle = 'rgba(255,200,150,0.18)'; ctx.lineWidth = 2; ctx.stroke();
        }
      }

      function drawBackground() {
        // vignette and horizon glow
        const w = world.w, h = world.h;
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#0c204f'); grad.addColorStop(0.6, '#0a1330'); grad.addColorStop(1, '#0b0f22');
        ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);
        const glow = ctx.createRadialGradient(w*0.5, 40, 10, w*0.5, 40, 260);
        glow.addColorStop(0, 'rgba(80,134,255,0.25)'); glow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(w*0.5, 40, 260, 0, TAU); ctx.fill();
      }

      function render(alpha) {
        ctx.save();
        ctx.translate(view.offX, view.offY);
        ctx.scale(view.scale, view.scale);
        drawBackground();
        // pegs
        for (let i=0;i<pegs.length;i++) if (!pegs[i].hit) drawPeg(pegs[i]);
        // particles behind ball
        particles.forEach(p => {
          const t = p.age / p.life; const a = (1 - t) * 0.7;
          ctx.beginPath(); ctx.arc(p.x, p.y, 2 + 2*(1-t), 0, TAU);
          ctx.globalAlpha = a; ctx.fillStyle = p.c; ctx.fill(); ctx.globalAlpha = 1;
        });
        // bucket
        drawBucket();
        // ball & trail
        if (ball.alive || state==='aim') {
          if (ball.alive) {
            trail.unshift({ x: ball.pos.x, y: ball.pos.y });
            if (trail.length > MAX_TRAIL) trail.pop();
          }
          drawBall();
        }
        // guide
        drawGuide();
        ctx.restore();
      }

      // -------- Main Loop --------
      function tick(now) {
        const dt = Math.min(33, now - lastT); lastT = now; accumulator += dt;
        let steps = 0;
        while (accumulator >= DT && steps < MAX_CATCH_UP) {
          stepBucket(DT);
          stepBall(DT);
          stepParticles(DT);
          accumulator -= DT; steps++;
        }
        render(accumulator / DT);
        requestAnimationFrame(tick);
      }

      // -------- Boot --------
      window.addEventListener('resize', resize);
      resize();
      resetLevel();
      requestAnimationFrame((t)=>{ lastT=t; requestAnimationFrame(tick); });

      // Polyfill for roundRect on some older canvases
      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){ r=Math.min(r, Math.abs(w)/2, Math.abs(h)/2); this.beginPath(); this.moveTo(x+r,y); this.arcTo(x+w,y,x+w,y+h,r); this.arcTo(x+w,y+h,x,y+h,r); this.arcTo(x,y+h,x,y,r); this.arcTo(x,y,x+w,y,r); this.closePath(); };
      }
    })();
    </script>
  </body>
</html>
