<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Peggle — Single‑File</title>
    <style>
      html, body {
        margin: 0;
        height: 100%;
        background: radial-gradient(1200px 800px at 50% 0%, #0b1736 0%, #0a0f24 60%, #060a18 100%);
        color: #e8eefc;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        overflow: hidden;
      }
      #wrap { position: fixed; inset: 0; display: grid; place-items: center; }
      canvas { display: block; background: transparent; image-rendering: optimizeQuality; }
      .hud {
        position: fixed; left: 50%; top: 16px; transform: translateX(-50%);
        display: flex; gap: 24px; align-items: center; padding: 6px 12px;
        background: rgba(10,16,30,0.45); border: 1px solid rgba(255,255,255,0.08);
        border-radius: 999px; backdrop-filter: blur(8px);
        box-shadow: 0 6px 24px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.06);
        pointer-events: auto; user-select: none;
        font-weight: 600; letter-spacing: 0.2px; font-size: 14px;
        font-variant-numeric: tabular-nums; font-feature-settings: 'tnum';
      }
      .hud .pill { padding: 4px 12px; border-radius: 999px; background: rgba(255,255,255,0.06); display: flex; align-items: center; gap: 6px; white-space: nowrap; }
      .hud .lbl { font-weight: 800; opacity: 0.95; }
      .hud .accent { color: #8ec7ff; display: inline-block; text-align: right; }
      .pill.score .accent { width: 8ch; }
      .pill.balls .accent { width: 2ch; }
      .pill.targets .accent { width: 3ch; }
      .pill.streak .accent { width: 3ch; }
      .controls { display: flex; gap: 8px; }
      .btn { cursor: pointer; padding: 6px 12px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.08); color: #e8eefc; font-weight: 700; letter-spacing: 0.2px; }
      .btn:hover { background: rgba(255,255,255,0.14); }
      .btn:active { transform: translateY(1px); }
      .options {
        position: fixed; top: 64px; right: 16px; padding: 14px 16px; border-radius: 12px;
        background: rgba(10,16,30,0.6); border: 1px solid rgba(255,255,255,0.1);
        box-shadow: 0 12px 36px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.06);
        backdrop-filter: blur(8px); color: #e8eefc; font-size: 14px;
      }
      .options h3 { margin: 0 0 8px; font-size: 14px; font-weight: 800; letter-spacing: 0.3px; opacity: 0.9; }
      .opt-row { display: flex; align-items: center; gap: 10px; margin: 8px 0; }
      .opt-label { opacity: 0.85; min-width: 120px; }
      .seg { display: inline-flex; gap: 6px; }
      .seg button { cursor: pointer; padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.06); color: #e8eefc; }
      .seg button.active { background: rgba(166,209,255,0.18); border-color: rgba(166,209,255,0.5); }
      /* overlay removed */
      .footer { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.6; }
      a { color: #a6d1ff; text-decoration: none; border-bottom: 1px dotted rgba(166,209,255,0.5); }
    </style>
  </head>
  <body>
    <div id="wrap"><canvas id="game"></canvas></div>
    <div class="hud" id="hud">
      <div class="pill score"><span class="lbl">Score</span><span id="score" class="accent">0</span></div>
      <div class="pill balls"><span class="lbl">Balls</span><span id="balls" class="accent">5</span></div>
      <div class="pill targets"><span class="lbl">Targets</span><span id="targets" class="accent">0</span></div>
      <div class="pill streak"><span class="lbl">Streak</span><span id="streak" class="accent">0</span></div>
      <div class="controls">
        <button class="btn" id="btnRestart" title="Restart with a new layout">Restart</button>
        <button class="btn" id="btnOptions" title="Toggle options">Options</button>
      </div>
    </div>
    <div class="options" id="optionsPanel" hidden>
      <h3>Options</h3>
      <div class="opt-row">
        <div class="opt-label">Guide bounces</div>
        <div class="seg" id="segBounces">
          <button data-v="1" class="active">1</button>
          <button data-v="2">2</button>
          <button data-v="3">3</button>
        </div>
      </div>
      <div class="opt-row" style="opacity:.7">More settings coming next…</div>
    </div>
    <div class="footer">Single-file build • Fixed-step physics • No network</div>
    <script>
    (() => {
      'use strict';

      // -------- Utilities --------
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const TAU = Math.PI * 2;

      class RNG { // Mulberry32
        constructor(seed = 0x9e3779b9) { this.s = seed >>> 0; }
        next() { let t = this.s += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }
        range(a, b) { return a + (b - a) * this.next(); }
        pick(arr) { return arr[(this.next() * arr.length) | 0]; }
      }

      class Vec2 {
        constructor(x=0, y=0) { this.x=x; this.y=y; }
        set(x,y){ this.x=x; this.y=y; return this; }
        copy(v){ this.x=v.x; this.y=v.y; return this; }
        add(v){ this.x+=v.x; this.y+=v.y; return this; }
        sub(v){ this.x-=v.x; this.y-=v.y; return this; }
        scl(s){ this.x*=s; this.y*=s; return this; }
        len(){ return Math.hypot(this.x, this.y); }
        nrm(){ const l=this.len()||1; this.x/=l; this.y/=l; return this; }
        dot(v){ return this.x*v.x + this.y*v.y; }
        clone(){ return new Vec2(this.x, this.y); }
      }

      // -------- Rendering & Scaling --------
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const world = { w: 960, h: 540 };
      let view = { w: 0, h: 0, scale: 1, offX: 0, offY: 0 };
      function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const W = window.innerWidth, H = window.innerHeight;
        const scale = Math.min(W / world.w, H / world.h);
        const w = Math.round(world.w * scale), h = Math.round(world.h * scale);
        view = { w, h, scale, offX: (W - w) >> 1, offY: (H - h) >> 1 };
        canvas.width = Math.max(1, Math.round(w * dpr));
        canvas.height = Math.max(1, Math.round(h * dpr));
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      // -------- Game State --------
      const rng = new RNG(0x1234cafe);
      const pegs = []; // {x,y,r,type:'normal'|'target', hit:boolean, glow:number}
      const particles = []; // pooled
      const trail = []; // recent positions for ball trail
      const MAX_TRAIL = 24;

      const BALL_R = 9;
      const BALL_REST = 0.96;
      const PEG_REST = 0.94;
      const WALL_REST = 0.90;
      const GRAVITY = 1200; // px/s^2 (tuned for 120 Hz)
      const DT = 1000 / 120; // ms per physics step
      const MAX_CATCH_UP = 2; // max physics steps per frame
      const LAUNCH_SPEED = 780; // px/s, gives fuller board reach

      let bucket = { x: world.w * 0.5, y: world.h - 36, w: 120, h: 20, speed: 220, dir: 1 };
      let ball = { pos: new Vec2(world.w*0.5, 80), vel: new Vec2(0,0), alive: false };
      let ballsLeft = 5;
      let score = 0;
      let streak = 0;
      let targetsLeft = 0;
      const opts = { guideBounces: 1 };
      let state = 'aim'; // 'aim' | 'fly' | 'win' | 'lose'
      let accumulator = 0; let lastT = performance.now();

      // HUD elements
      const hudScore = document.getElementById('score');
      const hudBalls = document.getElementById('balls');
      const hudTargets = document.getElementById('targets');
      const hudStreak = document.getElementById('streak');
      const btnRestart = document.getElementById('btnRestart');
      
      const btnOptions = document.getElementById('btnOptions');
      const optionsPanel = document.getElementById('optionsPanel');
      const segBounces = document.getElementById('segBounces');
      

      function resetLevel(seed = 0x1234cafe) {
        rng.s = seed >>> 0;
        pegs.length = 0; particles.length = 0; trail.length = 0;
        // Layout: hex grid cluster
        const cols = 12, rows = 7, spacing = 62, r = 12;
        const startX = (world.w - (cols-1) * spacing) * 0.5;
        const startY = 150;
        const targetIndices = new Set();
        // pick ~20% targets
        const total = cols * rows; const targetCount = Math.round(total * 0.22);
        while (targetIndices.size < targetCount) targetIndices.add((rng.next()*total)|0);
        let idx = 0;
        for (let j=0;j<rows;j++) {
          for (let i=0;i<cols;i++) {
            const x = startX + i*spacing + (j%2 ? spacing*0.5 : 0);
            const y = startY + j*spacing*0.86;
            if (x < 60 || x > world.w-60) continue; // trim edges
            const type = targetIndices.has(idx) ? 'target' : 'normal';
            pegs.push({ x, y, r, type, hit:false, glow:0 });
            idx++;
          }
        }
        targetsLeft = pegs.filter(p=>p.type==='target').length;
        bucket = { x: world.w*0.5, y: world.h-36, w: 120, h: 20, speed: 220, dir: 1 };
        ball.pos.set(world.w*0.5, 80); ball.vel.set(0,0); ball.alive=false;
        ballsLeft = 5; score = 0; streak = 0; state='aim';
        updateHUD();
      }

      function updateHUD() {
        hudScore.textContent = String(score);
        hudBalls.textContent = String(ballsLeft);
        hudTargets.textContent = String(targetsLeft);
        hudStreak.textContent = String(streak);
      }

      

      // -------- Input & Aiming --------
      const pointer = { x: world.w*0.5, y: 200, down:false };
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const sx = (e.clientX - rect.left) / rect.width;
        const sy = (e.clientY - rect.top) / rect.height;
        pointer.x = world.w * sx;
        pointer.y = world.h * sy;
      });
      canvas.addEventListener('mousedown', () => { pointer.down = true; });
      canvas.addEventListener('mouseup', () => { pointer.down = false; });
      window.addEventListener('blur', ()=> pointer.down=false);
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') { shoot(); }
      });
      btnRestart.addEventListener('click', () => { resetLevel((Math.random()*0xffffffff)>>>0); });
      btnOptions.addEventListener('click', () => { optionsPanel.hidden = !optionsPanel.hidden; });
      segBounces.addEventListener('click', (e) => {
        const b = e.target.closest('button'); if (!b) return;
        const val = parseInt(b.dataset.v, 10);
        const isActive = b.classList.contains('active');
        // Toggle off if clicking the active one
        if (isActive) {
          opts.guideBounces = 0;
          Array.from(segBounces.children).forEach(ch => ch.classList.remove('active'));
        } else {
          opts.guideBounces = val;
          Array.from(segBounces.children).forEach(ch => ch.classList.toggle('active', ch === b));
        }
      });

      function shoot() {
        if (state !== 'aim' || ballsLeft <= 0) return;
        const dir = Math.atan2(pointer.y - ball.pos.y, pointer.x - ball.pos.x);
        const speed = LAUNCH_SPEED;
        ball.vel.set(Math.cos(dir)*speed, Math.sin(dir)*speed);
        ball.alive = true; state = 'fly'; streak = 0; trail.length = 0;
        // no HUD messages
      }

      canvas.addEventListener('click', shoot);

      // -------- Particles --------
      function emitHit(x, y, color) {
        const count = 14;
        for (let i=0;i<count;i++) {
          const a = rng.range(0, TAU);
          const sp = rng.range(80, 240);
          particles.push({ x, y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: rng.range(280, 520), age: 0, c: color });
        }
      }

      function stepParticles(dt) {
        for (let i=particles.length-1;i>=0;i--) {
          const p = particles[i];
          p.age += dt; if (p.age >= p.life) { particles.splice(i,1); continue; }
          p.vx *= 0.992; p.vy = p.vy*0.992 + GRAVITY * 0.62 * (dt/1000); // slight gravity
          p.x += p.vx * dt/1000; p.y += p.vy * dt/1000;
        }
      }

      // -------- Physics --------
      function reflectVelocity(vx, vy, nx, ny, rest) {
        const dot = vx*nx + vy*ny;
        const rx = vx - (1+rest) * dot * nx;
        const ry = vy - (1+rest) * dot * ny;
        return [rx, ry];
      }

      function circleCollide(x,y,r, px,py,pr) { // returns normal & penetration
        const dx = x-px, dy = y-py; const d2 = dx*dx + dy*dy; const rr = (r+pr)*(r+pr);
        if (d2 >= rr) return null; const d = Math.sqrt(d2)||1; const nx = dx/d, ny = dy/d; const pen = (r+pr)-d; return { nx, ny, pen };
      }

      function stepBucket(dt) {
        bucket.x += bucket.dir * bucket.speed * dt/1000;
        const margin = 24;
        if (bucket.x - bucket.w*0.5 < margin) { bucket.x = margin + bucket.w*0.5; bucket.dir = 1; }
        if (bucket.x + bucket.w*0.5 > world.w - margin) { bucket.x = world.w - margin - bucket.w*0.5; bucket.dir = -1; }
      }

      function stepBall(dt) {
        if (!ball.alive) return;
        // increase substeps based on speed to mitigate tunneling
        const speed = ball.vel.len();
        const sub = Math.min(4, 1 + ((speed > 800) ? 2 : 0));
        const sdt = dt / sub;
        for (let k=0;k<sub;k++) {
          // integrate
          ball.vel.y += GRAVITY * (sdt/1000);
          ball.vel.x *= 0.999; ball.vel.y *= 0.999;
          ball.pos.x += ball.vel.x * sdt/1000;
          ball.pos.y += ball.vel.y * sdt/1000;

          // walls
          if (ball.pos.x < BALL_R) { ball.pos.x = BALL_R; ball.vel.x = Math.abs(ball.vel.x)*WALL_REST; }
          if (ball.pos.x > world.w-BALL_R) { ball.pos.x = world.w-BALL_R; ball.vel.x = -Math.abs(ball.vel.x)*WALL_REST; }
          if (ball.pos.y < BALL_R) { ball.pos.y = BALL_R; ball.vel.y = Math.abs(ball.vel.y)*WALL_REST; }

          // bucket catch (sensor at top of bucket)
          const withinX = Math.abs(ball.pos.x - bucket.x) < (bucket.w*0.5 - BALL_R*0.5);
          const nearTop = ball.pos.y > bucket.y - bucket.h*0.5 - BALL_R && ball.pos.y < bucket.y + bucket.h*0.2;
          if (withinX && nearTop && ball.vel.y > 0) {
            emitHit(ball.pos.x, ball.pos.y, '#ffd166');
            ballsLeft++; updateHUD();
            ball.alive = false; state = (targetsLeft<=0) ? 'win' : 'aim';
            ball.pos.set(world.w*0.5, 80); ball.vel.set(0,0); trail.length=0; streak=0;
            // no HUD messages
            return;
          }

          // pegs
          for (let i=pegs.length-1;i>=0;i--) {
            const p = pegs[i]; if (p.hit) continue;
            const col = circleCollide(ball.pos.x, ball.pos.y, BALL_R, p.x, p.y, p.r);
            if (!col) continue;
            // resolve position
            ball.pos.x += col.nx * col.pen;
            ball.pos.y += col.ny * col.pen;
            // reflect velocity
            let [rx, ry] = reflectVelocity(ball.vel.x, ball.vel.y, col.nx, col.ny, (BALL_REST+PEG_REST)*0.5);
            ball.vel.set(rx, ry);
            // scoring & effects
            p.hit = true; p.glow = 1;
            const base = (p.type === 'target') ? 150 : 50;
            score += Math.round(base * (1 + streak*0.12));
            streak += 1; updateHUD();
            emitHit(p.x, p.y, p.type==='target' ? '#ff9f6e' : '#66ccff');
            if (p.type==='target') { targetsLeft--; updateHUD(); if (targetsLeft<=0) { /* win when ball finishes */ } }
          }
        }

        // floor (miss)
        if (ball.pos.y > world.h + BALL_R) {
          ballsLeft--; updateHUD();
          ball.alive = false; trail.length=0; streak=0;
          if (targetsLeft<=0) { state='win'; }
          else if (ballsLeft>0) { state='aim'; }
          else { state='lose'; }
          ball.pos.set(world.w*0.5, 80); ball.vel.set(0,0);
        }
      }

      // -------- Guide Prediction (replicates fixed-step + substeps) --------
      function computeGuide() {
        if (opts.guideBounces <= 0 || state !== 'aim') return null;
        const start = ball.pos.clone();
        const dir = Math.atan2(pointer.y - start.y, pointer.x - start.x);
        const pos = start.clone();
        const vel = new Vec2(Math.cos(dir)*LAUNCH_SPEED, Math.sin(dir)*LAUNCH_SPEED);
        const maxMs = 2000;
        let elapsed = 0;
        const pts = [pos.clone()];
        let bounces = 0;
        let finalHit = null;
        // Simulate using the same integration and collision order as runtime
        while (elapsed < maxMs && bounces < opts.guideBounces) {
          const speed = vel.len();
          const sub = Math.min(4, 1 + ((speed > 800) ? 2 : 0));
          const sdt = DT / sub; // ms
          for (let k=0; k<sub; k++) {
            // integrate
            vel.y += GRAVITY * (sdt/1000);
            vel.x *= 0.999; vel.y *= 0.999;
            pos.x += vel.x * sdt/1000;
            pos.y += vel.y * sdt/1000;

            // walls
            if (pos.x < BALL_R) { pos.x = BALL_R; vel.x = Math.abs(vel.x)*WALL_REST; }
            if (pos.x > world.w-BALL_R) { pos.x = world.w-BALL_R; vel.x = -Math.abs(vel.x)*WALL_REST; }
            if (pos.y < BALL_R) { pos.y = BALL_R; vel.y = Math.abs(vel.y)*WALL_REST; }

            // pegs
            let collided = false;
            for (let i=pegs.length-1;i>=0;i--) {
              const p = pegs[i]; if (p.hit) continue;
              const col = circleCollide(pos.x, pos.y, BALL_R, p.x, p.y, p.r);
              if (!col) continue;
              // resolve like runtime
              pos.x += col.nx * col.pen;
              pos.y += col.ny * col.pen;
              const rv = reflectVelocity(vel.x, vel.y, col.nx, col.ny, (BALL_REST+PEG_REST)*0.5);
              vel.set(rv[0], rv[1]);
              bounces++;
              finalHit = { x: pos.x, y: pos.y };
              collided = true;
              break;
            }

            pts.push(pos.clone());
            if (bounces >= opts.guideBounces) break;
            if (pos.y > world.h + BALL_R + 40) break;
          }
          elapsed += DT;
          if (pos.y > world.h + BALL_R + 40) break;
        }
        return { pts, hit: finalHit };
      }

      // -------- Render --------
      function drawPeg(p) {
        const base = p.type==='target' ? '#ff7c47' : '#4fc3f7';
        const edge = p.type==='target' ? '#ffd1bd' : '#b8e7ff';
        // glow
        {
          const g = p.hit ? p.glow : 0.25 + 0.25*Math.sin(performance.now()*0.002 + p.x*0.01);
          if (g>0) {
            const r = p.r + 10*g;
            const grad = ctx.createRadialGradient(p.x, p.y, p.r*0.2, p.x, p.y, r);
            grad.addColorStop(0, p.type==='target' ? 'rgba(255,124,71,0.25)' : 'rgba(79,195,247,0.22)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, TAU); ctx.fill();
          }
        }
        // peg body
        ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, TAU);
        const grad2 = ctx.createLinearGradient(p.x, p.y-p.r, p.x, p.y+p.r);
        grad2.addColorStop(0, edge); grad2.addColorStop(1, base);
        ctx.fillStyle = grad2; ctx.fill();
        // rim
        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.stroke();
        if (p.hit) { p.glow = Math.max(0, p.glow - 0.06); }
      }

      function drawBucket() {
        const x = bucket.x, y = bucket.y, w = bucket.w, h = bucket.h;
        // glow
        {
          const grad = ctx.createRadialGradient(x, y, h*0.6, x, y, w*0.8);
          grad.addColorStop(0, 'rgba(255,231,91,0.12)'); grad.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grad; ctx.beginPath(); ctx.ellipse(x, y+6, w*0.7, h*1.2, 0, 0, TAU); ctx.fill();
        }
        // body
        ctx.beginPath();
        ctx.roundRect(x - w*0.5, y - h*0.5, w, h, 8);
        const grad2 = ctx.createLinearGradient(x, y-h*0.5, x, y+h*0.5);
        grad2.addColorStop(0, '#ffe75b'); grad2.addColorStop(1, '#d99a23');
        ctx.fillStyle = grad2; ctx.fill();
        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.stroke();
      }

      function drawBall() {
        // trail
        if (trail.length>1) {
          for (let i=1;i<trail.length;i++) {
            const t = i/(trail.length-1);
            const a = 0.28 * (t*t);
            ctx.beginPath(); ctx.arc(trail[i].x, trail[i].y, BALL_R*(0.6 + 0.4*t), 0, TAU);
            ctx.fillStyle = `rgba(174,209,255,${a.toFixed(3)})`; ctx.fill();
          }
        }
        // ball
        ctx.beginPath(); ctx.arc(ball.pos.x, ball.pos.y, BALL_R, 0, TAU);
        const g = ctx.createRadialGradient(ball.pos.x-3, ball.pos.y-3, BALL_R*0.2, ball.pos.x, ball.pos.y, BALL_R);
        g.addColorStop(0, '#ffffff'); g.addColorStop(1, '#8bbcff');
        ctx.fillStyle = g; ctx.fill();
        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.stroke();
      }

      function drawGuide() {
        const g = computeGuide(); if (!g) return;
        const n = g.pts.length; if (n < 2) return;
        // Draw breadcrumb dots with fade towards the end
        const startA = 0.6, endA = 0.12;
        const step = Math.max(1, Math.floor(n/64));
        for (let i=0;i<n; i+=step) {
          const p = g.pts[i];
          const t = i/(n-1);
          const a = lerp(startA, endA, t*t);
          ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, TAU);
          ctx.fillStyle = `rgba(230,240,255,${a.toFixed(3)})`;
          ctx.fill();
        }
        // Subtle mark on final hit
        if (g.hit) {
          ctx.beginPath(); ctx.arc(g.hit.x, g.hit.y, 6, 0, TAU);
          ctx.strokeStyle = 'rgba(255,200,150,0.18)'; ctx.lineWidth = 2; ctx.stroke();
        }
      }

      function drawBackground() {
        // vignette and horizon glow
        const w = world.w, h = world.h;
        const grad = ctx.createLinearGradient(0, 0, 0, h);
        grad.addColorStop(0, '#0c204f'); grad.addColorStop(0.6, '#0a1330'); grad.addColorStop(1, '#0b0f22');
        ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);
        const glow = ctx.createRadialGradient(w*0.5, 40, 10, w*0.5, 40, 260);
        glow.addColorStop(0, 'rgba(80,134,255,0.25)'); glow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(w*0.5, 40, 260, 0, TAU); ctx.fill();
      }

      function render(alpha) {
        ctx.save();
        ctx.translate(view.offX, view.offY);
        ctx.scale(view.scale, view.scale);
        drawBackground();
        // pegs
        for (let i=0;i<pegs.length;i++) if (!pegs[i].hit) drawPeg(pegs[i]);
        // particles behind ball
        particles.forEach(p => {
          const t = p.age / p.life; const a = (1 - t) * 0.7;
          ctx.beginPath(); ctx.arc(p.x, p.y, 2 + 2*(1-t), 0, TAU);
          ctx.globalAlpha = a; ctx.fillStyle = p.c; ctx.fill(); ctx.globalAlpha = 1;
        });
        // bucket
        drawBucket();
        // ball & trail
        if (ball.alive || state==='aim') {
          if (ball.alive) {
            trail.unshift({ x: ball.pos.x, y: ball.pos.y });
            if (trail.length > MAX_TRAIL) trail.pop();
          }
          drawBall();
        }
        // guide
        drawGuide();
        ctx.restore();
      }

      // -------- Main Loop --------
      function tick(now) {
        const dt = Math.min(33, now - lastT); lastT = now; accumulator += dt;
        let steps = 0;
        while (accumulator >= DT && steps < MAX_CATCH_UP) {
          stepBucket(DT);
          stepBall(DT);
          stepParticles(DT);
          accumulator -= DT; steps++;
        }
        render(accumulator / DT);
        requestAnimationFrame(tick);
      }

      // -------- Boot --------
      window.addEventListener('resize', resize);
      resize();
      resetLevel();
      requestAnimationFrame((t)=>{ lastT=t; requestAnimationFrame(tick); });

      // Polyfill for roundRect on some older canvases
      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){ r=Math.min(r, Math.abs(w)/2, Math.abs(h)/2); this.beginPath(); this.moveTo(x+r,y); this.arcTo(x+w,y,x+w,y+h,r); this.arcTo(x+w,y+h,x,y+h,r); this.arcTo(x,y+h,x,y,r); this.arcTo(x,y,x+w,y,r); this.closePath(); };
      }
    })();
    </script>
  </body>
</html>

